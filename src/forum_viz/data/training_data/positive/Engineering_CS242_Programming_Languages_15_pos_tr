0:<Correct & thanks, sorry for not wanting to get into the third rule in class! :)>
1:<Got a partner already :)>
2:<I don't understand one of the pre-filled-in cases for the compiler generated code for the list comparison (dCompList). Maybe someone can help me out.

In the last case (compList (x:xs) (y:ys)), we have the if-then-else block where each block starts with the operator (?=). This operator extracts a comparison function from a dictionary. Using this operator makes sense to me for the "if" case and the "then" case as we want to extract the proper comparison function for the type present inside the list as that is what we are comparing (x and y). However, I don't see why this operator is filled in for the "else" case. To me it seems that the else case should just recursively call (compList xs ys) to compare the rest of the list. If we use that operator to extract the function from the dictionary, we'd have a function that compares ints when we actually want to compare lists.

Am I going crazy and missing something here?

Thanks,

-Chris>
3:<I agree that removing `(?=)` and adding `compList` is the most straightforward answer to this problem. But I guess we probably can't remove things from the problem. The good thing is, we can actually write `compList` in the form of `(?=) blablabla`.

Hope this helps.>
4:<That's right. 

And, yep you can't remove the code :)

Remeber that we're trying to write code that the compiler would generate, so the fact that the `(?=)` is there is a reflection of a general algorithm.>
5:<haha, I also wanted to remove that ?= because the example in the slide does not have something corresponding to "?=". However, compList = (?=) blablabla.>
6:<I believe that this problem is missing a pattern matching for _ _. Or am I missing something :)?>
7:<My apologies. I meant 2.d and yes, that link was the answer :)>
8:<The solution states that the second to last step:

 - ...
   =P((?y.P(y y))(?y.P(y y)))
   **=P((?f.(?x.f(x x))(?x.f(x x)))P)**
   =P(Y P)

is a eta-reduction. Isn't it an eta-abstraction instead since we are creating a wrapper around an expression?>
9:<For Q3 (a):
It seems like the following is also a valid solution, can someone confirm that? I tried this in Haskell, and it works.

    dCompList :: CompD a -> CompD [a]
    dCompList d = MakeCompD compList where
      compList [] [] = EQ
      compList (x:xs) [] = GT
      compList [] (y:ys) = LT
      compList (x:xs) (y:ys) =
        if ( ((?=) d x y) /= EQ)
        then ((?=) d x y)
        else ((?=) (MakeCompD compList) xs ys) {-different from solution-}

For Q4 (d): Does it have to be IO monad? Shouldn't all monads work in this problem? We found that the built-in MArray (mutable array) in haskell just requires a Monad m instead of IO monad.>
10:<Email that sould've been on the discussoin:

> I noticed that the 30th slide from type classes' type constructor
> looks vastly different from Hw3.2.a
> 
> Which one is correct and why? If both are correct? why they look
> different?

They are both correct. Looking different doesn't imply they're not correct. 
Here is an explanation

<code>
data MyEqD a = MkMyEqD { (===) :: a -> a -> Bool }
</code>

uses record notation. `MyEqD` a is a polymorphic data-type. `MyEqD` is a type contructor. `MkMyEqD` is the value constructor (used to created values e.g., of type MyEqD Int). Sometimes we use the same name for the value and type constructors. `(===)` is a function whose type is `MyEqD a -> (a -> a -> Bool)`.

We can alternatively write this as:

<code>
data MyEqD a = MkMyEqD (a -> a -> Bool)

(===) (MkMyEqD f) = f
</code>

</code>>
11:<Can you explain what (===) (MkMyEqD f) = f says? You're declaring a function (===) that takes one argument of type MkMyEqD and simply returns that argument?>
12:<(===) :: (MyEqD a) -> a -> a -> Bool, which means it takes an argument of type MyEqD a and produces a function (a -> a -> Bool) that you can use to check two a's for equality (returning a Bool).

MkMyEqD f constructs a value of type MyEqD a (where f :: (a -> a -> Bool) ).

The "(===) (MkMyEqD f) = f" part means that the function f that was used to create the MyEqD argument from the value constructor MkMyEqD will be returned from the (===) function.>
13:<Are they posted (I couldn't find them, but maybe I didn't look in the right place)? Thanks :)>
14:<You're missing something. If you read the question, it even states "function dispatch from a null object reference". Best advice: Just run it ;)>
